# Configuracao do Servidor para o contêiner
server.port=8085

# Configuracoes do Actuator
management.endpoints.web.exposure.include=health,info,prometheus
management.metrics.tags.application=microservice-radar-cart

# ==========================================================
# ##            CONFIGURACAO DO BANCO POSTGRESQL            ##
# ==========================================================
# Aponta para o servico 'postgres-db' que definiremos no Docker Compose
spring.datasource.url=jdbc:postgresql://postgres-db:5432/cart_db
spring.datasource.username=${POSTGRES_USER}
spring.datasource.password=${POSTGRES_PASSWORD}
spring.datasource.driverClassName=org.postgresql.Driver

# Define a plataforma base do banco de dados
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
# Define o DIALETO ESPECIAL PostGIS para Hibernate 6 (SEM .spatial no nome)
#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostGISDialect

#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostGISDialect
# Em producao, o Flyway cuidara disso. 'validate' é mais seguro.
spring.jpa.hibernate.ddl-auto=validate

# Adicionado para consistencia com seu arquivo do Config Server
# Habilita o Flyway para gerenciar o banco de dados
spring.flyway.enabled=true

# ==========================================================
# ##            CONFIGURACOES DO RABBITMQ                 ##
# ==========================================================
# Aponta para o serviço 'rabbitmq' no Docker Compose
spring.rabbitmq.host=rabbitmq
spring.rabbitmq.port=5672
spring.rabbitmq.username=${RABBITMQ_USER}
spring.rabbitmq.password=${RABBITMQ_PASSWORD}

# RabbitMQ Producer Configuration
rabbitmq.exchange.name=radares_exchange
rabbitmq.routing.key=radares.cart

# ? Query Plan Cache
spring.jpa.properties.hibernate.query.plan_cache_max_size=2048
spring.jpa.properties.hibernate.query.plan_parameter_metadata_max_size=128

# ? Statement Cache
spring.jpa.properties.hibernate.jdbc.fetch_size=50

# ? Desabilita logs desnecessários em produção
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=false
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=WARN

# ? Cache de segundo nível (opcional - use com cautela)
# spring.jpa.properties.hibernate.cache.use_second_level_cache=true
# spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory

# ============================================
# REDIS OTIMIZADO
# ============================================
spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.data.redis.timeout=2000ms
spring.data.redis.lettuce.pool.max-active=20
spring.data.redis.lettuce.pool.max-idle=10
spring.data.redis.lettuce.pool.min-idle=5
spring.data.redis.lettuce.pool.max-wait=2000ms

# ============================================
# TUNING ADICIONAL
# ============================================

# Tamanho do batch para FTP (reduz carga de I/O)
ftp.batch.size=1000

# Intervalo do scheduler (5 minutos)
ftp.schedule.rate.ms=300000

#Habilita Vitural Theads
spring.threads.virtual.enabled=true

# Thread pool para operações assíncronas
spring.task.execution.pool.core-size=10
spring.task.execution.pool.max-size=20
spring.task.execution.pool.queue-capacity=100

##Configuração do Pool de Conexões (HikariCP)
# Define o máximo de conexões ativas no pool
spring.datasource.hikari.maximum-pool-size=30
# Mantém um mínimo de conexões prontas para uso
spring.datasource.hikari.minimum-idle=10
# Tempo máximo que uma thread espera por uma conexão antes do timeout
spring.datasource.hikari.connection-timeout=30000
# Tempo máximo de vida de uma conexão no pool
spring.datasource.hikari.max-lifetime=1800000